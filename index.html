<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm visualizer</title>
    <style>
        .bar {
            width: 5px;
            display: inline-block;
            margin: 0 1px;
            background-color: blue;
        }
    </style>
</head>
<body>
    <h1>Algorithm visualizer</h1>
    <div>
        <input type="number" id="dataset-size" class="ipt-dataset-size" placeholder="Dataset size (min 5)" onblur="handleDatasetSizeChange()"/>
        <input type="number" id="search-number" class="ipt-search-number" placeholder="Enter number for search" onblur="handleSearchNumberChange()"/>
        <button id="generate-array" class="btn" onclick="generateArray()">Generate Array</button>
        <button id="linear-search" class="btn" onclick="doLinearSearch()">Linear Search</button>
        <button id="binary-search" class="btn" onclick="doBinarySearch()">Binary Search</button>
        <button id="bubble-sort" class="btn" onclick="doBubbleSort()">Bubble Sort</button>
        <button id="selection-sort" class="btn" onclick="doSelectionSort()">Selection Sort</button>
    </div>

    <div id="lines-container">

    </div>

    <script>
        // constants
        const BG_COLOR = 'blue'
        const COMPARE_COLOR = 'yellow'
        const FOUND_COLOR = 'green'
        const SELECT_COLOR = 'red'


        // utils
        function getRandomNumber(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

    </script>

    <script>
        // Algorithms for animations

        function getLinearSearchAnimations(searchNumber, array) {
            let animationArr = []
            for (let i = 0; i < array.length; ++i) {
                if (searchNumber === array[i]) {
                    animationArr.push({
                        pos: i,
                        found: true,
                    })

                    return animationArr
                } else {
                    animationArr.push({
                        pos: i,
                    })
                }
            }
            animationArr.push({
                pos: array.length - 1,
                found: false
            })

            return animationArr
        }

        function getBinarySearchAnimations(searchNumber, sortedArray) {
            let animationArr =  []

            let lowIndex = 0
            let highIndex = sortedArray.length - 1
            let midIndex
            animationArr.push({
                lowIndex,
                highIndex,
                status: 'compare',
            })
            while (lowIndex <= highIndex) {
                midIndex = Math.floor((lowIndex + highIndex) / 2)
                animationArr.push({
                    midIndex,
                    status: 'select'
                })
                if (sortedArray[midIndex] == searchNumber) {
                    animationArr.push({
                        midIndex,
                        status: 'found'
                    })
                    return animationArr
                } else if (sortedArray[midIndex] < searchNumber) {
                    lowIndex = midIndex + 1
                    animationArr.push({
                        lowIndex,
                        highIndex,
                        status: 'compare',
                    })
                } else {
                    highIndex = midIndex - 1
                    animationArr.push({
                        lowIndex,
                        highIndex,
                        status: 'compare',
                    })
                }
            }
            animationArr.push({
                lowIndex,
                midIndex,
                highIndex,
                status: 'not-found',
            })
            return animationArr;
        }

        function getBubbleSortAnimations(inputArr) {
            let animationArr = []
            let len = inputArr.length;
            let swapped;
            do {
                swapped = false;
                for (let i = 0; i < len - 1; i++) {
                    animationArr.push({
                        posI: i,
                        posJ: i + 1,
                        status: 'compare',
                    })
                    if (inputArr[i] > inputArr[i + 1]) {
                        animationArr.push({
                            posI: i,
                            posJ: i + 1,
                            status: 'swap',
                        })  
                        let tmp = inputArr[i];
                        inputArr[i] = inputArr[i + 1];
                        inputArr[i + 1] = tmp;
                        swapped = true;
                    }
                }
            } while (swapped);
            return animationArr;
        }

        function getSelectionSortAnimations(inputArr) {
            let animationArr = []
            let len = inputArr.length;
            for (let i = 0; i < len; i++) {
                let min = i
                animationArr.push({
                    min: i,
                    status: 'select-min',
                })
                for (let j = i + 1; j < len; j++) {
                    animationArr.push({
                        min,
                        j,
                        status: 'compare'
                    })
                    if (inputArr[min] > inputArr[j]) {
                        animationArr.push({
                            min: j,
                            status: 'select-min',
                        })
                        min = j
                    }
                }

                if (min !== i) {
                    animationArr.push({
                        min,
                        i,
                        status: 'swap'
                    })
                    let tmp = inputArr[i]
                    inputArr[i] = inputArr[min]
                    inputArr[min] = tmp
                }
            }
            return animationArr
        }

    </script>

    <script>
        let datasetSize = 5, searchNumber, array = [];

        function handleDatasetSizeChange() {
            datasetSize = Number(document.getElementById('dataset-size').value) >= 5 ? Number(document.getElementById('dataset-size').value) : 5
            document.getElementById('dataset-size').value = datasetSize
        }

        function handleSearchNumberChange() {
            searchNumber = Number(document.getElementById('search-number').value) >= 5 ? Number(document.getElementById('search-number').value) : 5
            document.getElementById('search-number').value = searchNumber
        }

        function generateArray() {
            let lineContainerElement = document.getElementById('lines-container')

            // Remove Present Children
            let child = lineContainerElement.lastElementChild;  
            while (child) { 
                lineContainerElement.removeChild(child); 
                child = lineContainerElement.lastElementChild; 
            }
            array = []

            // Add new Children
            for (let i = 0; i < datasetSize; ++i) {
                let randomNumber = getRandomNumber(5, 500)
                array.push(randomNumber)

                let lineElement = document.createElement('div')
                lineElement.className = "bar"
                lineElement.style.height = randomNumber + 'px'
                lineContainerElement.appendChild(lineElement)
            }
        }

        async function doLinearSearch() {
            if (!searchNumber) {
                alert('Enter search number!')
                document.getElementById('search-number').focus()
                return
            }

            if (!array.length) {
                alert('Generate Array!')
                document.getElementById('generate-array').focus()
                return
            }

            let animationArr = getLinearSearchAnimations(searchNumber, [...array])
            let lineContainerChildElements = Array.from(document.getElementById('lines-container').children)
            let previous
            for (let i = 0; i < animationArr.length; ++i) {
                let animation = animationArr[i]
                await sleep(100)
                
                if (Number.isInteger(previous)) {
                    lineContainerChildElements[previous].style.backgroundColor = BG_COLOR
                }

                if (animation.found === true) {
                    lineContainerChildElements[animation.pos].style.backgroundColor = FOUND_COLOR
                    alert('Found on position: ' + animation.pos)
                    return
                } else if (animation.found === false) {
                    lineContainerChildElements[animation.pos].style.backgroundColor = BG_COLOR
                    alert('Not found!')
                    return
                } else {
                    lineContainerChildElements[animation.pos].style.backgroundColor = SELECT_COLOR
                    previous = animation.pos
                }
            }
        }

        async function doBinarySearch() {
            if (!searchNumber) {
                alert('Enter search number!')
                document.getElementById('search-number').focus()
                return
            }

            if (!array.length) {
                alert('Generate Array!')
                document.getElementById('generate-array').focus()
                return
            }

            let lineContainerChildElements = Array.from(document.getElementById('lines-container').children).slice()
            
            // Sort array and dom elements before performing binary search
            array.sort((a, b) => a - b)
            lineContainerChildElements.sort((a, b) => parseInt(a.style.height) - parseInt(b.style.height))

            let lineContainerElement = document.getElementById('lines-container')

            // Remove Present Children
            let child = lineContainerElement.lastElementChild;
            while (child) { 
                lineContainerElement.removeChild(child); 
                child = lineContainerElement.lastElementChild; 
            }

            // Append the sorted childs
            for (let i = 0; i < array.length; ++i) {
                let lineElement = document.createElement('div')
                lineElement.className = "bar"
                lineElement.style.height = array[i] + 'px'
                lineContainerElement.appendChild(lineElement)
            }

            await sleep(1000)

            let animationArr = getBinarySearchAnimations(searchNumber, array)
            let previous
            lineContainerChildElements = Array.from(document.getElementById('lines-container').children)

            for (let i = 0; i < animationArr.length; ++i) {
                const animation = animationArr[i]
                await sleep(300)
                if (previous) {
                    if (previous.status === 'compare') {
                        lineContainerChildElements[previous.lowIndex].style.backgroundColor = BG_COLOR
                        lineContainerChildElements[previous.highIndex].style.backgroundColor = BG_COLOR
                    } else {
                        lineContainerChildElements[previous.midIndex].style.backgroundColor = BG_COLOR
                    }
                }

                if (animation.status === 'found') {
                    lineContainerChildElements[animation.midIndex].style.backgroundColor = FOUND_COLOR
                    alert('Found at index: ' + animation.midIndex)
                    return
                } else if (animation.status === 'not-found') {
                    lineContainerChildElements[animation.lowIndex].style.backgroundColor = BG_COLOR
                    lineContainerChildElements[animation.midIndex].style.backgroundColor = BG_COLOR
                    lineContainerChildElements[animation.highIndex].style.backgroundColor = BG_COLOR
                    alert('Not Found')
                    return
                } else if (animation.status === 'compare') {
                    lineContainerChildElements[animation.lowIndex].style.backgroundColor = COMPARE_COLOR
                    lineContainerChildElements[animation.highIndex].style.backgroundColor = COMPARE_COLOR
                    await sleep(300)
                } else {
                    lineContainerChildElements[animation.midIndex].style.backgroundColor = SELECT_COLOR
                }

                previous = animation
            }
        }
    
        async function doBubbleSort() {
            if (!array.length) {
                alert('Generate Array!')
                document.getElementById('generate-array').focus()
                return
            }

            let lineContainerChildElements = Array.from(document.getElementById('lines-container').children)
            let animationArr = getBubbleSortAnimations(array)
            let previous

            for (let i = 0; i < animationArr.length; ++i) {
                await sleep(300)
                if (previous) {
                    lineContainerChildElements[previous.posI].style.backgroundColor = BG_COLOR
                    lineContainerChildElements[previous.posJ].style.backgroundColor = BG_COLOR
                }
                const animation = animationArr[i]

                if (animation.status === 'compare') {
                    lineContainerChildElements[animation.posI].style.backgroundColor = COMPARE_COLOR
                    lineContainerChildElements[animation.posJ].style.backgroundColor = COMPARE_COLOR
                } else {
                    lineContainerChildElements[animation.posI].style.backgroundColor = SELECT_COLOR
                    lineContainerChildElements[animation.posJ].style.backgroundColor = SELECT_COLOR
                    const tempHeight = lineContainerChildElements[animation.posI].style.height
                    lineContainerChildElements[animation.posI].style.height = lineContainerChildElements[animation.posJ].style.height
                    lineContainerChildElements[animation.posJ].style.height = tempHeight
                }

                previous = animation
            }

            if (previous) {
                lineContainerChildElements[previous.posI].style.backgroundColor = BG_COLOR
                lineContainerChildElements[previous.posJ].style.backgroundColor = BG_COLOR
            }
        }

        async function doSelectionSort() {
            if (!array.length) {
                alert('Generate Array!')
                document.getElementById('generate-array').focus()
                return
            }

            let lineContainerChildElements = Array.from(document.getElementById('lines-container').children)
            let animationArr = getSelectionSortAnimations(array)
            let previous

            for (let i = 0; i < animationArr.length; ++i) {
                await sleep(300)
                if (previous) {
                    Number.isInteger(previous.min) && (lineContainerChildElements[previous.min].style.backgroundColor = BG_COLOR)
                    Number.isInteger(previous.j) && (lineContainerChildElements[previous.j].style.backgroundColor = BG_COLOR)
                    Number.isInteger(previous.i) && (lineContainerChildElements[previous.i].style.backgroundColor = BG_COLOR)
                }
                const animation = animationArr[i]

                if (animation.status === 'compare') {
                    lineContainerChildElements[animation.min].style.backgroundColor = COMPARE_COLOR
                    lineContainerChildElements[animation.j].style.backgroundColor = COMPARE_COLOR
                } else if (animation.status === 'swap') {
                    lineContainerChildElements[animation.min].style.backgroundColor = SELECT_COLOR
                    lineContainerChildElements[animation.i].style.backgroundColor = SELECT_COLOR
                    const tempHeight = lineContainerChildElements[animation.min].style.height
                    lineContainerChildElements[animation.min].style.height = lineContainerChildElements[animation.i].style.height
                    lineContainerChildElements[animation.i].style.height = tempHeight
                } else {
                    lineContainerChildElements[animation.min].style.backgroundColor = FOUND_COLOR
                }

                previous = animation
            }

            if (previous) {
                Number.isInteger(previous.min) && (lineContainerChildElements[previous.min].style.backgroundColor = BG_COLOR)
                Number.isInteger(previous.j) && (lineContainerChildElements[previous.j].style.backgroundColor = BG_COLOR)
                Number.isInteger(previous.i) && (lineContainerChildElements[previous.i].style.backgroundColor = BG_COLOR)
            }
        }

    </script>
</body>
</html>